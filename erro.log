docker compose up test
Attaching to test-1
test-1  | Requirement already satisfied: Flask<3.0.0,>=2.0.3 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements.txt (line 1)) (2.2.2)
test-1  | Requirement already satisfied: SQLAlchemy<3.0.0,>=1.4.32 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements.txt (line 2)) (1.4.32)
test-1  | Requirement already satisfied: pg8000<2.0.0,>=1.24.1 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements.txt (line 3)) (1.24.1)
test-1  | Requirement already satisfied: nsj_gcf_utils<2.0.0,>=1.0.22 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements.txt (line 4)) (1.0.23)
test-1  | Requirement already satisfied: PyMySQL<2.0.0,>=1.0.2 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements.txt (line 5)) (1.1.2)
test-1  | Requirement already satisfied: py-healthcheck<2.0.0,>=1.10.1 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements.txt (line 6)) (1.10.1)
test-1  | Requirement already satisfied: unidecode<2.0.0,>=1.0.22 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements.txt (line 7)) (1.4.0)
test-1  | Requirement already satisfied: opentelemetry-exporter-otlp<2.0.0,>=1.32.1 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements.txt (line 8)) (1.38.0)
test-1  | Requirement already satisfied: pyyaml<7.0.0,>=6.0.3 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements.txt (line 9)) (6.0.3)
test-1  | Requirement already satisfied: Werkzeug>=2.2.2 in /usr/lib/python3.10/site-packages (from Flask<3.0.0,>=2.0.3->-r /var/www/html/requirements.txt (line 1)) (2.2.2)
test-1  | Requirement already satisfied: Jinja2>=3.0 in /usr/lib/python3.10/site-packages (from Flask<3.0.0,>=2.0.3->-r /var/www/html/requirements.txt (line 1)) (3.1.2)
test-1  | Requirement already satisfied: itsdangerous>=2.0 in /usr/lib/python3.10/site-packages (from Flask<3.0.0,>=2.0.3->-r /var/www/html/requirements.txt (line 1)) (2.1.2)
test-1  | Requirement already satisfied: click>=8.0 in /usr/lib/python3.10/site-packages (from Flask<3.0.0,>=2.0.3->-r /var/www/html/requirements.txt (line 1)) (8.1.7)
test-1  | Requirement already satisfied: greenlet!=0.4.17 in /usr/lib/python3.10/site-packages (from SQLAlchemy<3.0.0,>=1.4.32->-r /var/www/html/requirements.txt (line 2)) (3.0.1)
test-1  | Requirement already satisfied: scramp>=1.4.1 in /usr/lib/python3.10/site-packages (from pg8000<2.0.0,>=1.24.1->-r /var/www/html/requirements.txt (line 3)) (1.4.4)
test-1  | Requirement already satisfied: requests>=2.26.0 in /usr/lib/python3.10/site-packages (from nsj_gcf_utils<2.0.0,>=1.0.22->-r /var/www/html/requirements.txt (line 4)) (2.28.0)
test-1  | Requirement already satisfied: sqlparams>=3.0.0 in /usr/lib/python3.10/site-packages (from nsj_gcf_utils<2.0.0,>=1.0.22->-r /var/www/html/requirements.txt (line 4)) (6.2.0)
test-1  | Requirement already satisfied: pydantic>=1.9.0 in /usr/lib/python3.10/site-packages (from nsj_gcf_utils<2.0.0,>=1.0.22->-r /var/www/html/requirements.txt (line 4)) (1.9.0)
test-1  | Requirement already satisfied: python_dateutil<3.0.0,>=2.9.0 in /usr/lib/python3.10/site-packages (from nsj_gcf_utils<2.0.0,>=1.0.22->-r /var/www/html/requirements.txt (line 4)) (2.9.0.post0)
test-1  | Requirement already satisfied: six in /usr/lib/python3.10/site-packages (from py-healthcheck<2.0.0,>=1.10.1->-r /var/www/html/requirements.txt (line 6)) (1.16.0)
test-1  | Requirement already satisfied: opentelemetry-exporter-otlp-proto-grpc==1.38.0 in /usr/lib/python3.10/site-packages (from opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (1.38.0)
test-1  | Requirement already satisfied: opentelemetry-exporter-otlp-proto-http==1.38.0 in /usr/lib/python3.10/site-packages (from opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (1.38.0)
test-1  | Requirement already satisfied: googleapis-common-protos~=1.57 in /usr/lib/python3.10/site-packages (from opentelemetry-exporter-otlp-proto-grpc==1.38.0->opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (1.72.0)
test-1  | Requirement already satisfied: grpcio<2.0.0,>=1.63.2 in /usr/lib/python3.10/site-packages (from opentelemetry-exporter-otlp-proto-grpc==1.38.0->opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (1.76.0)
test-1  | Requirement already satisfied: opentelemetry-api~=1.15 in /usr/lib/python3.10/site-packages (from opentelemetry-exporter-otlp-proto-grpc==1.38.0->opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (1.38.0)
test-1  | Requirement already satisfied: opentelemetry-exporter-otlp-proto-common==1.38.0 in /usr/lib/python3.10/site-packages (from opentelemetry-exporter-otlp-proto-grpc==1.38.0->opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (1.38.0)
test-1  | Requirement already satisfied: opentelemetry-proto==1.38.0 in /usr/lib/python3.10/site-packages (from opentelemetry-exporter-otlp-proto-grpc==1.38.0->opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (1.38.0)
test-1  | Requirement already satisfied: opentelemetry-sdk~=1.38.0 in /usr/lib/python3.10/site-packages (from opentelemetry-exporter-otlp-proto-grpc==1.38.0->opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (1.38.0)
test-1  | Requirement already satisfied: typing-extensions>=4.6.0 in /usr/lib/python3.10/site-packages (from opentelemetry-exporter-otlp-proto-grpc==1.38.0->opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (4.15.0)
test-1  | Requirement already satisfied: protobuf<7.0,>=5.0 in /usr/lib/python3.10/site-packages (from opentelemetry-proto==1.38.0->opentelemetry-exporter-otlp-proto-grpc==1.38.0->opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (6.33.0)
test-1  | Requirement already satisfied: MarkupSafe>=2.0 in /usr/lib/python3.10/site-packages (from Jinja2>=3.0->Flask<3.0.0,>=2.0.3->-r /var/www/html/requirements.txt (line 1)) (2.1.3)
test-1  | Requirement already satisfied: charset-normalizer~=2.0.0 in /usr/lib/python3.10/site-packages (from requests>=2.26.0->nsj_gcf_utils<2.0.0,>=1.0.22->-r /var/www/html/requirements.txt (line 4)) (2.0.12)
test-1  | Requirement already satisfied: idna<4,>=2.5 in /usr/lib/python3.10/site-packages (from requests>=2.26.0->nsj_gcf_utils<2.0.0,>=1.0.22->-r /var/www/html/requirements.txt (line 4)) (3.6)
test-1  | Requirement already satisfied: urllib3<1.27,>=1.21.1 in /usr/lib/python3.10/site-packages (from requests>=2.26.0->nsj_gcf_utils<2.0.0,>=1.0.22->-r /var/www/html/requirements.txt (line 4)) (1.26.18)
test-1  | Requirement already satisfied: certifi>=2017.4.17 in /usr/lib/python3.10/site-packages (from requests>=2.26.0->nsj_gcf_utils<2.0.0,>=1.0.22->-r /var/www/html/requirements.txt (line 4)) (2023.11.17)
test-1  | Requirement already satisfied: asn1crypto>=1.5.1 in /usr/lib/python3.10/site-packages (from scramp>=1.4.1->pg8000<2.0.0,>=1.24.1->-r /var/www/html/requirements.txt (line 3)) (1.5.1)
test-1  | Requirement already satisfied: importlib-metadata<8.8.0,>=6.0 in /usr/lib/python3.10/site-packages (from opentelemetry-api~=1.15->opentelemetry-exporter-otlp-proto-grpc==1.38.0->opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (8.7.0)
test-1  | Requirement already satisfied: opentelemetry-semantic-conventions==0.59b0 in /usr/lib/python3.10/site-packages (from opentelemetry-sdk~=1.38.0->opentelemetry-exporter-otlp-proto-grpc==1.38.0->opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (0.59b0)
test-1  | Requirement already satisfied: zipp>=3.20 in /usr/lib/python3.10/site-packages (from importlib-metadata<8.8.0,>=6.0->opentelemetry-api~=1.15->opentelemetry-exporter-otlp-proto-grpc==1.38.0->opentelemetry-exporter-otlp<2.0.0,>=1.32.1->-r /var/www/html/requirements.txt (line 8)) (3.23.0)
test-1  | Requirement already satisfied: nsj-rest-test-util<1.0.0,>=0.1.13 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements-dev.txt (line 1)) (0.1.14)
test-1  | Requirement already satisfied: pytest>=7.1.3 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements-dev.txt (line 2)) (8.4.2)
test-1  | Requirement already satisfied: coverage==7.6.8 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements-dev.txt (line 3)) (7.6.8)
test-1  | Requirement already satisfied: pylint==3.3.2 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements-dev.txt (line 4)) (3.3.2)
test-1  | Requirement already satisfied: build==1.2.2 in /usr/lib/python3.10/site-packages (from -r /var/www/html/requirements-dev.txt (line 5)) (1.2.2)
test-1  | Requirement already satisfied: dill>=0.2 in /usr/lib/python3.10/site-packages (from pylint==3.3.2->-r /var/www/html/requirements-dev.txt (line 4)) (0.4.0)
test-1  | Requirement already satisfied: platformdirs>=2.2.0 in /usr/lib/python3.10/site-packages (from pylint==3.3.2->-r /var/www/html/requirements-dev.txt (line 4)) (4.5.0)
test-1  | Requirement already satisfied: astroid<=3.4.0-dev0,>=3.3.5 in /usr/lib/python3.10/site-packages (from pylint==3.3.2->-r /var/www/html/requirements-dev.txt (line 4)) (3.3.11)
test-1  | Requirement already satisfied: isort!=5.13.0,<6,>=4.2.5 in /usr/lib/python3.10/site-packages (from pylint==3.3.2->-r /var/www/html/requirements-dev.txt (line 4)) (5.13.2)
test-1  | Requirement already satisfied: mccabe<0.8,>=0.6 in /usr/lib/python3.10/site-packages (from pylint==3.3.2->-r /var/www/html/requirements-dev.txt (line 4)) (0.7.0)
test-1  | Requirement already satisfied: tomli>=1.1.0 in /usr/lib/python3.10/site-packages (from pylint==3.3.2->-r /var/www/html/requirements-dev.txt (line 4)) (2.0.1)
test-1  | Requirement already satisfied: tomlkit>=0.10.1 in /usr/lib/python3.10/site-packages (from pylint==3.3.2->-r /var/www/html/requirements-dev.txt (line 4)) (0.13.3)
test-1  | Requirement already satisfied: packaging>=19.1 in /usr/lib/python3.10/site-packages (from build==1.2.2->-r /var/www/html/requirements-dev.txt (line 5)) (21.3)
test-1  | Requirement already satisfied: pyproject_hooks in /usr/lib/python3.10/site-packages (from build==1.2.2->-r /var/www/html/requirements-dev.txt (line 5)) (1.2.0)
test-1  | Requirement already satisfied: asn1crypto>=1.5.1 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (1.5.1)
test-1  | Requirement already satisfied: attrs>=22.1.0 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (25.4.0)
test-1  | Requirement already satisfied: Authlib>=1.0.0 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (1.0.0)
test-1  | Requirement already satisfied: certifi>=2022.9.24 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (2023.11.17)
test-1  | Requirement already satisfied: cffi>=1.15.1 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (1.16.0)
test-1  | Requirement already satisfied: charset-normalizer>=2.0.12 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (2.0.12)
test-1  | Requirement already satisfied: click>=8.1.3 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (8.1.7)
test-1  | Requirement already satisfied: cryptography>=38.0.1 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (41.0.7)
test-1  | Requirement already satisfied: Flask>=2.0.3 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (2.2.2)
test-1  | Requirement already satisfied: greenlet>=1.1.3 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (3.0.1)
test-1  | Requirement already satisfied: idna>=3.4 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (3.6)
test-1  | Requirement already satisfied: iniconfig>=1.1.1 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (2.3.0)
test-1  | Requirement already satisfied: itsdangerous>=2.1.2 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (2.1.2)
test-1  | Requirement already satisfied: Jinja2>=3.1.2 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (3.1.2)
test-1  | Requirement already satisfied: jsonpickle>=2.2.0 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (4.1.1)
test-1  | Requirement already satisfied: MarkupSafe>=2.1.1 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (2.1.3)
test-1  | Requirement already satisfied: nsj-gcf-utils>=1.0.9 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (1.0.23)
test-1  | Requirement already satisfied: pendulum>=2.1.2 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (3.1.0)
test-1  | Requirement already satisfied: pg8000>=1.24.1 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (1.24.1)
test-1  | Requirement already satisfied: pluggy>=1.0.0 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (1.6.0)
test-1  | Requirement already satisfied: ptvsd>=4.3.2 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (4.3.2)
test-1  | Requirement already satisfied: py>=1.11.0 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (1.11.0)
test-1  | Requirement already satisfied: pycparser>=2.21 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (2.21)
test-1  | Requirement already satisfied: pydantic>=1.9.0 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (1.9.0)
test-1  | Requirement already satisfied: pyparsing>=3.0.9 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (3.2.5)
test-1  | Requirement already satisfied: python-dateutil>=2.8.2 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (2.9.0.post0)
test-1  | Requirement already satisfied: pytzdata>=2020.1 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (2020.1)
test-1  | Requirement already satisfied: requests>=2.26.0 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (2.28.0)
test-1  | Requirement already satisfied: scramp>=1.4.1 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (1.4.4)
test-1  | Requirement already satisfied: six>=1.16.0 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (1.16.0)
test-1  | Requirement already satisfied: SQLAlchemy>=1.4.32 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (1.4.32)
test-1  | Requirement already satisfied: sqlparams>=3.0.0 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (6.2.0)
test-1  | Requirement already satisfied: typing_extensions>=4.3.0 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (4.15.0)
test-1  | Requirement already satisfied: urllib3>=1.26.12 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (1.26.18)
test-1  | Requirement already satisfied: Werkzeug>=2.2.2 in /usr/lib/python3.10/site-packages (from nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (2.2.2)
test-1  | Requirement already satisfied: exceptiongroup>=1 in /usr/lib/python3.10/site-packages (from pytest>=7.1.3->-r /var/www/html/requirements-dev.txt (line 2)) (1.3.0)
test-1  | Requirement already satisfied: pygments>=2.7.2 in /usr/lib/python3.10/site-packages (from pytest>=7.1.3->-r /var/www/html/requirements-dev.txt (line 2)) (2.19.2)
test-1  | Requirement already satisfied: tzdata>=2020.1 in /usr/lib/python3.10/site-packages (from pendulum>=2.1.2->nsj-rest-test-util<1.0.0,>=0.1.13->-r /var/www/html/requirements-dev.txt (line 1)) (2025.2)
test-1  | ============================= test session starts ==============================
test-1  | platform linux -- Python 3.10.13, pytest-8.4.2, pluggy-1.6.0
test-1  | rootdir: /var/www/html
test-1  | configfile: pyproject.toml
test-1  | ['/var/www/html/tests/api/casos_de_teste/clientes/delete', '/usr/bin', '/var/www/html', '/usr/lib/python310.zip', '/usr/lib/python3.10', '/usr/lib/python3.10/lib-dynload', '/usr/lib/python3.10/site-packages']
test-1  | ['/var/www/html/tests/api/casos_de_teste/clientes/get', '/var/www/html/tests/api/casos_de_teste/clientes/delete', '/usr/bin', '/var/www/html', '/usr/lib/python310.zip', '/usr/lib/python3.10', '/usr/lib/python3.10/lib-dynload', '/usr/lib/python3.10/site-packages']
test-1  | ['/var/www/html/tests/api/casos_de_teste/clientes/put', '/var/www/html/tests/api/casos_de_teste/clientes/post', '/var/www/html/tests/api/casos_de_teste/clientes/get', '/var/www/html/tests/api/casos_de_teste/clientes/delete', '/usr/bin', '/var/www/html', '/usr/lib/python310.zip', '/usr/lib/python3.10', '/usr/lib/python3.10/lib-dynload', '/usr/lib/python3.10/site-packages']
test-1  | collected 9 items
test-1  | 
test-1  | tests/api/casos_de_teste/clientes/delete/test_clientes_delete.py 
test-1  | JSON: exemplo1_204	(pg8000.dbapi.ProgrammingError) query was empty
test-1  | [SQL: 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | {'tenant': '99999'}
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | E
test-1  | JSON: exemplo2_204	(pg8000.dbapi.ProgrammingError) query was empty
test-1  | [SQL: 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | {'tenant': '99999'}
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | E
test-1  | tests/api/casos_de_teste/clientes/get/test_clientes_get.py 
test-1  | JSON: exemplo3_200	(pg8000.dbapi.ProgrammingError) query was empty
test-1  | [SQL: 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | {'tenant': '99999'}
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | E
test-1  | JSON: exemplo5_200	(pg8000.dbapi.ProgrammingError) query was empty
test-1  | [SQL: 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | {'tenant': '99999'}
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | E
test-1  | JSON: exemplo2_200	(pg8000.dbapi.ProgrammingError) query was empty
test-1  | [SQL: 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | {'tenant': '99999'}
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | E
test-1  | JSON: exemplo1_200	(pg8000.dbapi.ProgrammingError) query was empty
test-1  | [SQL: 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | {'tenant': '99999'}
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | E
test-1  | JSON: exemplo4_200	(pg8000.dbapi.ProgrammingError) query was empty
test-1  | [SQL: 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | {'tenant': '99999'}
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | E
test-1  | tests/api/casos_de_teste/clientes/post/test_clientes_post.py 
test-1  | JSON: exemplo1_201	(pg8000.dbapi.ProgrammingError) query was empty
test-1  | [SQL: 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | {'tenant': '99999'}
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | E
test-1  | tests/api/casos_de_teste/clientes/put/test_clientes_put.py 
test-1  | JSON: exemplo1_204	(pg8000.dbapi.ProgrammingError) query was empty
test-1  | [SQL: 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | {'tenant': '99999'}
test-1  | 
test-1  | 
test-1  | -- INSERT INTO teste.classificacoesfinanceiras
test-1  | -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)
test-1  | E
test-1  | 
test-1  | ==================================== ERRORS ====================================
test-1  | _ ERROR at setup of TestClientesDELETE.test_get[exemplo1_204-/var/www/html/tests/api/casos_de_teste/clientes/delete/entradas_json/exemplo1_204.json] _
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f4807b0ea40>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  | >               self._context = self._c.execute_simple(operation)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:249: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:617: in execute_simple
test-1  |     self.handle_messages(context)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Connection object at 0x7f4807b0dde0>
test-1  | context = <pg8000.core.Context object at 0x7f4807b0e4a0>
test-1  | 
test-1  |     def handle_messages(self, context):
test-1  |         code = self.error = None
test-1  |     
test-1  |         while code != READY_FOR_QUERY:
test-1  |     
test-1  |             try:
test-1  |                 code, data_len = ci_unpack(self._read(5))
test-1  |             except struct.error as e:
test-1  |                 raise InterfaceError("network error on read") from e
test-1  |     
test-1  |             self.message_types[code](self._read(data_len - 4), context)
test-1  |     
test-1  |         if self.error is not None:
test-1  | >           raise self.error
test-1  | E           pg8000.exceptions.DatabaseError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:764: DatabaseError
test-1  | 
test-1  | During handling of the above exception, another exception occurred:
test-1  | 
test-1  | self = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | dialect = <sqlalchemy.dialects.postgresql.pg8000.PGDialect_pg8000 object at 0x7f4808cbfca0>
test-1  | constructor = <bound method DefaultExecutionContext._init_statement of <class 'sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000'>>
test-1  | statement = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | parameters = (), execution_options = immutabledict({})
test-1  | args = ("\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao,...06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)", [])
test-1  | kw = {}, branched = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x7f4807b0ded0>
test-1  | context = <sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000 object at 0x7f4807b0e6e0>
test-1  | cursor = <pg8000.legacy.Cursor object at 0x7f4807b0ea40>, evt_handled = False
test-1  | 
test-1  |     def _execute_context(
test-1  |         self,
test-1  |         dialect,
test-1  |         constructor,
test-1  |         statement,
test-1  |         parameters,
test-1  |         execution_options,
test-1  |         *args,
test-1  |         **kw
test-1  |     ):
test-1  |         """Create an :class:`.ExecutionContext` and execute, returning
test-1  |         a :class:`_engine.CursorResult`."""
test-1  |     
test-1  |         branched = self
test-1  |         if self.__branch_from:
test-1  |             # if this is a "branched" connection, do everything in terms
test-1  |             # of the "root" connection, *except* for .close(), which is
test-1  |             # the only feature that branching provides
test-1  |             self = self.__branch_from
test-1  |     
test-1  |         try:
test-1  |             conn = self._dbapi_connection
test-1  |             if conn is None:
test-1  |                 conn = self._revalidate_connection()
test-1  |     
test-1  |             context = constructor(
test-1  |                 dialect, self, conn, execution_options, *args, **kw
test-1  |             )
test-1  |         except (exc.PendingRollbackError, exc.ResourceClosedError):
test-1  |             raise
test-1  |         except BaseException as e:
test-1  |             self._handle_dbapi_exception(
test-1  |                 e, util.text_type(statement), parameters, None, None
test-1  |             )
test-1  |     
test-1  |         if (
test-1  |             self._transaction
test-1  |             and not self._transaction.is_active
test-1  |             or (
test-1  |                 self._nested_transaction
test-1  |                 and not self._nested_transaction.is_active
test-1  |             )
test-1  |         ):
test-1  |             self._invalid_transaction()
test-1  |     
test-1  |         elif self._trans_context_manager:
test-1  |             TransactionalContext._trans_ctx_check(self)
test-1  |     
test-1  |         if self._is_future and self._transaction is None:
test-1  |             self._autobegin()
test-1  |     
test-1  |         context.pre_exec()
test-1  |     
test-1  |         if dialect.use_setinputsizes:
test-1  |             context._set_input_sizes()
test-1  |     
test-1  |         cursor, statement, parameters = (
test-1  |             context.cursor,
test-1  |             context.statement,
test-1  |             context.parameters,
test-1  |         )
test-1  |     
test-1  |         if not context.executemany:
test-1  |             parameters = parameters[0]
test-1  |     
test-1  |         if self._has_events or self.engine._has_events:
test-1  |             for fn in self.dispatch.before_cursor_execute:
test-1  |                 statement, parameters = fn(
test-1  |                     self,
test-1  |                     cursor,
test-1  |                     statement,
test-1  |                     parameters,
test-1  |                     context,
test-1  |                     context.executemany,
test-1  |                 )
test-1  |     
test-1  |         if self._echo:
test-1  |     
test-1  |             self._log_info(statement)
test-1  |     
test-1  |             stats = context._get_cache_stats()
test-1  |     
test-1  |             if not self.engine.hide_parameters:
test-1  |                 self._log_info(
test-1  |                     "[%s] %r",
test-1  |                     stats,
test-1  |                     sql_util._repr_params(
test-1  |                         parameters, batches=10, ismulti=context.executemany
test-1  |                     ),
test-1  |                 )
test-1  |             else:
test-1  |                 self._log_info(
test-1  |                     "[%s] [SQL parameters hidden due to hide_parameters=True]"
test-1  |                     % (stats,)
test-1  |                 )
test-1  |     
test-1  |         evt_handled = False
test-1  |         try:
test-1  |             if context.executemany:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_executemany:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_executemany(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  |             elif not parameters and context.no_parameters:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute_no_params:
test-1  |                         if fn(cursor, statement, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_execute_no_params(
test-1  |                         cursor, statement, context
test-1  |                     )
test-1  |             else:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  | >                   self.dialect.do_execute(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f4807b0ea40>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               pg8000.dbapi.ProgrammingError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | 
test-1  | The above exception was the direct cause of the following exception:
test-1  | 
test-1  | self = <test_clientes_delete.TestClientesDELETE object at 0x7f4809e41690>
test-1  | json_entrada_nome = 'exemplo1_204'
test-1  | 
test-1  |     @pytest.fixture(scope="class", autouse=True)
test-1  |     def setup(self, json_entrada_nome):
test-1  | >       test_util.pre_setup(json_entrada_nome, True)
test-1  | 
test-1  | tests/api/casos_de_teste/clientes/delete/test_clientes_delete.py:24: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/tcase_util.py:43: in pre_setup
test-1  |     DumpUtil.dump_from_sqls([self.global_sql], params_tenant)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:18: in dump_from_sqls
test-1  |     DumpUtil.dump_sql_if_exists(file_path, file_params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:135: in dump_sql_if_exists
test-1  |     DumpUtil.dump_from_sql(file_path, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:104: in dump_from_sql
test-1  |     DumpUtil.dump_sql_command(command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:36: in dump_sql_command
test-1  |     response = repository.execute(sql_command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:108: in execute
test-1  |     cursor = self.__execute_retornando_cursor(sql, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:195: in __execute_retornando_cursor
test-1  |     cursor = self.__con.execute(sql2, param3)
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1280: in execute
test-1  |     return self._exec_driver_sql(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1584: in _exec_driver_sql
test-1  |     ret = self._execute_context(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1851: in _execute_context
test-1  |     self._handle_dbapi_exception(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2032: in _handle_dbapi_exception
test-1  |     util.raise_(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/util/compat.py:207: in raise_
test-1  |     raise exception
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: in _execute_context
test-1  |     self.dialect.do_execute(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f4807b0ea40>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               sqlalchemy.exc.ProgrammingError: (pg8000.dbapi.ProgrammingError) query was empty
test-1  | E               [SQL: 
test-1  | E               
test-1  | E               -- INSERT INTO teste.classificacoesfinanceiras
test-1  | E               -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | E               -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | E               (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | _ ERROR at setup of TestClientesDELETE.test_get[exemplo2_204-/var/www/html/tests/api/casos_de_teste/clientes/delete/entradas_json/exemplo2_204.json] _
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f48071cb550>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  | >               self._context = self._c.execute_simple(operation)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:249: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:617: in execute_simple
test-1  |     self.handle_messages(context)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Connection object at 0x7f4807b0dde0>
test-1  | context = <pg8000.core.Context object at 0x7f48071cb520>
test-1  | 
test-1  |     def handle_messages(self, context):
test-1  |         code = self.error = None
test-1  |     
test-1  |         while code != READY_FOR_QUERY:
test-1  |     
test-1  |             try:
test-1  |                 code, data_len = ci_unpack(self._read(5))
test-1  |             except struct.error as e:
test-1  |                 raise InterfaceError("network error on read") from e
test-1  |     
test-1  |             self.message_types[code](self._read(data_len - 4), context)
test-1  |     
test-1  |         if self.error is not None:
test-1  | >           raise self.error
test-1  | E           pg8000.exceptions.DatabaseError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:764: DatabaseError
test-1  | 
test-1  | During handling of the above exception, another exception occurred:
test-1  | 
test-1  | self = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | dialect = <sqlalchemy.dialects.postgresql.pg8000.PGDialect_pg8000 object at 0x7f4808cbfca0>
test-1  | constructor = <bound method DefaultExecutionContext._init_statement of <class 'sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000'>>
test-1  | statement = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | parameters = (), execution_options = immutabledict({})
test-1  | args = ("\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao,...06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)", [])
test-1  | kw = {}, branched = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x7f4807b0ded0>
test-1  | context = <sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000 object at 0x7f48071cac80>
test-1  | cursor = <pg8000.legacy.Cursor object at 0x7f48071cb550>, evt_handled = False
test-1  | 
test-1  |     def _execute_context(
test-1  |         self,
test-1  |         dialect,
test-1  |         constructor,
test-1  |         statement,
test-1  |         parameters,
test-1  |         execution_options,
test-1  |         *args,
test-1  |         **kw
test-1  |     ):
test-1  |         """Create an :class:`.ExecutionContext` and execute, returning
test-1  |         a :class:`_engine.CursorResult`."""
test-1  |     
test-1  |         branched = self
test-1  |         if self.__branch_from:
test-1  |             # if this is a "branched" connection, do everything in terms
test-1  |             # of the "root" connection, *except* for .close(), which is
test-1  |             # the only feature that branching provides
test-1  |             self = self.__branch_from
test-1  |     
test-1  |         try:
test-1  |             conn = self._dbapi_connection
test-1  |             if conn is None:
test-1  |                 conn = self._revalidate_connection()
test-1  |     
test-1  |             context = constructor(
test-1  |                 dialect, self, conn, execution_options, *args, **kw
test-1  |             )
test-1  |         except (exc.PendingRollbackError, exc.ResourceClosedError):
test-1  |             raise
test-1  |         except BaseException as e:
test-1  |             self._handle_dbapi_exception(
test-1  |                 e, util.text_type(statement), parameters, None, None
test-1  |             )
test-1  |     
test-1  |         if (
test-1  |             self._transaction
test-1  |             and not self._transaction.is_active
test-1  |             or (
test-1  |                 self._nested_transaction
test-1  |                 and not self._nested_transaction.is_active
test-1  |             )
test-1  |         ):
test-1  |             self._invalid_transaction()
test-1  |     
test-1  |         elif self._trans_context_manager:
test-1  |             TransactionalContext._trans_ctx_check(self)
test-1  |     
test-1  |         if self._is_future and self._transaction is None:
test-1  |             self._autobegin()
test-1  |     
test-1  |         context.pre_exec()
test-1  |     
test-1  |         if dialect.use_setinputsizes:
test-1  |             context._set_input_sizes()
test-1  |     
test-1  |         cursor, statement, parameters = (
test-1  |             context.cursor,
test-1  |             context.statement,
test-1  |             context.parameters,
test-1  |         )
test-1  |     
test-1  |         if not context.executemany:
test-1  |             parameters = parameters[0]
test-1  |     
test-1  |         if self._has_events or self.engine._has_events:
test-1  |             for fn in self.dispatch.before_cursor_execute:
test-1  |                 statement, parameters = fn(
test-1  |                     self,
test-1  |                     cursor,
test-1  |                     statement,
test-1  |                     parameters,
test-1  |                     context,
test-1  |                     context.executemany,
test-1  |                 )
test-1  |     
test-1  |         if self._echo:
test-1  |     
test-1  |             self._log_info(statement)
test-1  |     
test-1  |             stats = context._get_cache_stats()
test-1  |     
test-1  |             if not self.engine.hide_parameters:
test-1  |                 self._log_info(
test-1  |                     "[%s] %r",
test-1  |                     stats,
test-1  |                     sql_util._repr_params(
test-1  |                         parameters, batches=10, ismulti=context.executemany
test-1  |                     ),
test-1  |                 )
test-1  |             else:
test-1  |                 self._log_info(
test-1  |                     "[%s] [SQL parameters hidden due to hide_parameters=True]"
test-1  |                     % (stats,)
test-1  |                 )
test-1  |     
test-1  |         evt_handled = False
test-1  |         try:
test-1  |             if context.executemany:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_executemany:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_executemany(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  |             elif not parameters and context.no_parameters:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute_no_params:
test-1  |                         if fn(cursor, statement, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_execute_no_params(
test-1  |                         cursor, statement, context
test-1  |                     )
test-1  |             else:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  | >                   self.dialect.do_execute(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f48071cb550>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               pg8000.dbapi.ProgrammingError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | 
test-1  | The above exception was the direct cause of the following exception:
test-1  | 
test-1  | self = <test_clientes_delete.TestClientesDELETE object at 0x7f4809e41690>
test-1  | json_entrada_nome = 'exemplo2_204'
test-1  | 
test-1  |     @pytest.fixture(scope="class", autouse=True)
test-1  |     def setup(self, json_entrada_nome):
test-1  | >       test_util.pre_setup(json_entrada_nome, True)
test-1  | 
test-1  | tests/api/casos_de_teste/clientes/delete/test_clientes_delete.py:24: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/tcase_util.py:43: in pre_setup
test-1  |     DumpUtil.dump_from_sqls([self.global_sql], params_tenant)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:18: in dump_from_sqls
test-1  |     DumpUtil.dump_sql_if_exists(file_path, file_params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:135: in dump_sql_if_exists
test-1  |     DumpUtil.dump_from_sql(file_path, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:104: in dump_from_sql
test-1  |     DumpUtil.dump_sql_command(command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:36: in dump_sql_command
test-1  |     response = repository.execute(sql_command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:108: in execute
test-1  |     cursor = self.__execute_retornando_cursor(sql, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:195: in __execute_retornando_cursor
test-1  |     cursor = self.__con.execute(sql2, param3)
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1280: in execute
test-1  |     return self._exec_driver_sql(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1584: in _exec_driver_sql
test-1  |     ret = self._execute_context(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1851: in _execute_context
test-1  |     self._handle_dbapi_exception(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2032: in _handle_dbapi_exception
test-1  |     util.raise_(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/util/compat.py:207: in raise_
test-1  |     raise exception
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: in _execute_context
test-1  |     self.dialect.do_execute(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f48071cb550>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               sqlalchemy.exc.ProgrammingError: (pg8000.dbapi.ProgrammingError) query was empty
test-1  | E               [SQL: 
test-1  | E               
test-1  | E               -- INSERT INTO teste.classificacoesfinanceiras
test-1  | E               -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | E               -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | E               (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | _ ERROR at setup of TestClientesGET.test_get[exemplo3_200-/var/www/html/tests/api/casos_de_teste/clientes/get/entradas_json/exemplo3_200.json] _
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480760c8e0>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  | >               self._context = self._c.execute_simple(operation)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:249: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:617: in execute_simple
test-1  |     self.handle_messages(context)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Connection object at 0x7f4807b0dde0>
test-1  | context = <pg8000.core.Context object at 0x7f480760c850>
test-1  | 
test-1  |     def handle_messages(self, context):
test-1  |         code = self.error = None
test-1  |     
test-1  |         while code != READY_FOR_QUERY:
test-1  |     
test-1  |             try:
test-1  |                 code, data_len = ci_unpack(self._read(5))
test-1  |             except struct.error as e:
test-1  |                 raise InterfaceError("network error on read") from e
test-1  |     
test-1  |             self.message_types[code](self._read(data_len - 4), context)
test-1  |     
test-1  |         if self.error is not None:
test-1  | >           raise self.error
test-1  | E           pg8000.exceptions.DatabaseError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:764: DatabaseError
test-1  | 
test-1  | During handling of the above exception, another exception occurred:
test-1  | 
test-1  | self = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | dialect = <sqlalchemy.dialects.postgresql.pg8000.PGDialect_pg8000 object at 0x7f4808cbfca0>
test-1  | constructor = <bound method DefaultExecutionContext._init_statement of <class 'sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000'>>
test-1  | statement = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | parameters = (), execution_options = immutabledict({})
test-1  | args = ("\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao,...06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)", [])
test-1  | kw = {}, branched = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x7f4807b0ded0>
test-1  | context = <sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000 object at 0x7f480760c0d0>
test-1  | cursor = <pg8000.legacy.Cursor object at 0x7f480760c8e0>, evt_handled = False
test-1  | 
test-1  |     def _execute_context(
test-1  |         self,
test-1  |         dialect,
test-1  |         constructor,
test-1  |         statement,
test-1  |         parameters,
test-1  |         execution_options,
test-1  |         *args,
test-1  |         **kw
test-1  |     ):
test-1  |         """Create an :class:`.ExecutionContext` and execute, returning
test-1  |         a :class:`_engine.CursorResult`."""
test-1  |     
test-1  |         branched = self
test-1  |         if self.__branch_from:
test-1  |             # if this is a "branched" connection, do everything in terms
test-1  |             # of the "root" connection, *except* for .close(), which is
test-1  |             # the only feature that branching provides
test-1  |             self = self.__branch_from
test-1  |     
test-1  |         try:
test-1  |             conn = self._dbapi_connection
test-1  |             if conn is None:
test-1  |                 conn = self._revalidate_connection()
test-1  |     
test-1  |             context = constructor(
test-1  |                 dialect, self, conn, execution_options, *args, **kw
test-1  |             )
test-1  |         except (exc.PendingRollbackError, exc.ResourceClosedError):
test-1  |             raise
test-1  |         except BaseException as e:
test-1  |             self._handle_dbapi_exception(
test-1  |                 e, util.text_type(statement), parameters, None, None
test-1  |             )
test-1  |     
test-1  |         if (
test-1  |             self._transaction
test-1  |             and not self._transaction.is_active
test-1  |             or (
test-1  |                 self._nested_transaction
test-1  |                 and not self._nested_transaction.is_active
test-1  |             )
test-1  |         ):
test-1  |             self._invalid_transaction()
test-1  |     
test-1  |         elif self._trans_context_manager:
test-1  |             TransactionalContext._trans_ctx_check(self)
test-1  |     
test-1  |         if self._is_future and self._transaction is None:
test-1  |             self._autobegin()
test-1  |     
test-1  |         context.pre_exec()
test-1  |     
test-1  |         if dialect.use_setinputsizes:
test-1  |             context._set_input_sizes()
test-1  |     
test-1  |         cursor, statement, parameters = (
test-1  |             context.cursor,
test-1  |             context.statement,
test-1  |             context.parameters,
test-1  |         )
test-1  |     
test-1  |         if not context.executemany:
test-1  |             parameters = parameters[0]
test-1  |     
test-1  |         if self._has_events or self.engine._has_events:
test-1  |             for fn in self.dispatch.before_cursor_execute:
test-1  |                 statement, parameters = fn(
test-1  |                     self,
test-1  |                     cursor,
test-1  |                     statement,
test-1  |                     parameters,
test-1  |                     context,
test-1  |                     context.executemany,
test-1  |                 )
test-1  |     
test-1  |         if self._echo:
test-1  |     
test-1  |             self._log_info(statement)
test-1  |     
test-1  |             stats = context._get_cache_stats()
test-1  |     
test-1  |             if not self.engine.hide_parameters:
test-1  |                 self._log_info(
test-1  |                     "[%s] %r",
test-1  |                     stats,
test-1  |                     sql_util._repr_params(
test-1  |                         parameters, batches=10, ismulti=context.executemany
test-1  |                     ),
test-1  |                 )
test-1  |             else:
test-1  |                 self._log_info(
test-1  |                     "[%s] [SQL parameters hidden due to hide_parameters=True]"
test-1  |                     % (stats,)
test-1  |                 )
test-1  |     
test-1  |         evt_handled = False
test-1  |         try:
test-1  |             if context.executemany:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_executemany:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_executemany(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  |             elif not parameters and context.no_parameters:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute_no_params:
test-1  |                         if fn(cursor, statement, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_execute_no_params(
test-1  |                         cursor, statement, context
test-1  |                     )
test-1  |             else:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  | >                   self.dialect.do_execute(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480760c8e0>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               pg8000.dbapi.ProgrammingError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | 
test-1  | The above exception was the direct cause of the following exception:
test-1  | 
test-1  | self = <test_clientes_get.TestClientesGET object at 0x7f4809918e80>
test-1  | json_entrada_nome = 'exemplo3_200'
test-1  | 
test-1  |     @pytest.fixture(scope="class", autouse=True)
test-1  |     def setup(self, json_entrada_nome):
test-1  | >       test_util.pre_setup(json_entrada_nome, True)
test-1  | 
test-1  | tests/api/casos_de_teste/clientes/get/test_clientes_get.py:23: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/tcase_util.py:43: in pre_setup
test-1  |     DumpUtil.dump_from_sqls([self.global_sql], params_tenant)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:18: in dump_from_sqls
test-1  |     DumpUtil.dump_sql_if_exists(file_path, file_params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:135: in dump_sql_if_exists
test-1  |     DumpUtil.dump_from_sql(file_path, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:104: in dump_from_sql
test-1  |     DumpUtil.dump_sql_command(command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:36: in dump_sql_command
test-1  |     response = repository.execute(sql_command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:108: in execute
test-1  |     cursor = self.__execute_retornando_cursor(sql, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:195: in __execute_retornando_cursor
test-1  |     cursor = self.__con.execute(sql2, param3)
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1280: in execute
test-1  |     return self._exec_driver_sql(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1584: in _exec_driver_sql
test-1  |     ret = self._execute_context(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1851: in _execute_context
test-1  |     self._handle_dbapi_exception(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2032: in _handle_dbapi_exception
test-1  |     util.raise_(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/util/compat.py:207: in raise_
test-1  |     raise exception
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: in _execute_context
test-1  |     self.dialect.do_execute(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480760c8e0>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               sqlalchemy.exc.ProgrammingError: (pg8000.dbapi.ProgrammingError) query was empty
test-1  | E               [SQL: 
test-1  | E               
test-1  | E               -- INSERT INTO teste.classificacoesfinanceiras
test-1  | E               -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | E               -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | E               (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | _ ERROR at setup of TestClientesGET.test_get[exemplo5_200-/var/www/html/tests/api/casos_de_teste/clientes/get/entradas_json/exemplo5_200.json] _
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480a13d390>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  | >               self._context = self._c.execute_simple(operation)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:249: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:617: in execute_simple
test-1  |     self.handle_messages(context)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Connection object at 0x7f4807b0dde0>
test-1  | context = <pg8000.core.Context object at 0x7f480a13f790>
test-1  | 
test-1  |     def handle_messages(self, context):
test-1  |         code = self.error = None
test-1  |     
test-1  |         while code != READY_FOR_QUERY:
test-1  |     
test-1  |             try:
test-1  |                 code, data_len = ci_unpack(self._read(5))
test-1  |             except struct.error as e:
test-1  |                 raise InterfaceError("network error on read") from e
test-1  |     
test-1  |             self.message_types[code](self._read(data_len - 4), context)
test-1  |     
test-1  |         if self.error is not None:
test-1  | >           raise self.error
test-1  | E           pg8000.exceptions.DatabaseError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:764: DatabaseError
test-1  | 
test-1  | During handling of the above exception, another exception occurred:
test-1  | 
test-1  | self = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | dialect = <sqlalchemy.dialects.postgresql.pg8000.PGDialect_pg8000 object at 0x7f4808cbfca0>
test-1  | constructor = <bound method DefaultExecutionContext._init_statement of <class 'sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000'>>
test-1  | statement = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | parameters = (), execution_options = immutabledict({})
test-1  | args = ("\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao,...06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)", [])
test-1  | kw = {}, branched = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x7f4807b0ded0>
test-1  | context = <sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000 object at 0x7f480a13fd30>
test-1  | cursor = <pg8000.legacy.Cursor object at 0x7f480a13d390>, evt_handled = False
test-1  | 
test-1  |     def _execute_context(
test-1  |         self,
test-1  |         dialect,
test-1  |         constructor,
test-1  |         statement,
test-1  |         parameters,
test-1  |         execution_options,
test-1  |         *args,
test-1  |         **kw
test-1  |     ):
test-1  |         """Create an :class:`.ExecutionContext` and execute, returning
test-1  |         a :class:`_engine.CursorResult`."""
test-1  |     
test-1  |         branched = self
test-1  |         if self.__branch_from:
test-1  |             # if this is a "branched" connection, do everything in terms
test-1  |             # of the "root" connection, *except* for .close(), which is
test-1  |             # the only feature that branching provides
test-1  |             self = self.__branch_from
test-1  |     
test-1  |         try:
test-1  |             conn = self._dbapi_connection
test-1  |             if conn is None:
test-1  |                 conn = self._revalidate_connection()
test-1  |     
test-1  |             context = constructor(
test-1  |                 dialect, self, conn, execution_options, *args, **kw
test-1  |             )
test-1  |         except (exc.PendingRollbackError, exc.ResourceClosedError):
test-1  |             raise
test-1  |         except BaseException as e:
test-1  |             self._handle_dbapi_exception(
test-1  |                 e, util.text_type(statement), parameters, None, None
test-1  |             )
test-1  |     
test-1  |         if (
test-1  |             self._transaction
test-1  |             and not self._transaction.is_active
test-1  |             or (
test-1  |                 self._nested_transaction
test-1  |                 and not self._nested_transaction.is_active
test-1  |             )
test-1  |         ):
test-1  |             self._invalid_transaction()
test-1  |     
test-1  |         elif self._trans_context_manager:
test-1  |             TransactionalContext._trans_ctx_check(self)
test-1  |     
test-1  |         if self._is_future and self._transaction is None:
test-1  |             self._autobegin()
test-1  |     
test-1  |         context.pre_exec()
test-1  |     
test-1  |         if dialect.use_setinputsizes:
test-1  |             context._set_input_sizes()
test-1  |     
test-1  |         cursor, statement, parameters = (
test-1  |             context.cursor,
test-1  |             context.statement,
test-1  |             context.parameters,
test-1  |         )
test-1  |     
test-1  |         if not context.executemany:
test-1  |             parameters = parameters[0]
test-1  |     
test-1  |         if self._has_events or self.engine._has_events:
test-1  |             for fn in self.dispatch.before_cursor_execute:
test-1  |                 statement, parameters = fn(
test-1  |                     self,
test-1  |                     cursor,
test-1  |                     statement,
test-1  |                     parameters,
test-1  |                     context,
test-1  |                     context.executemany,
test-1  |                 )
test-1  |     
test-1  |         if self._echo:
test-1  |     
test-1  |             self._log_info(statement)
test-1  |     
test-1  |             stats = context._get_cache_stats()
test-1  |     
test-1  |             if not self.engine.hide_parameters:
test-1  |                 self._log_info(
test-1  |                     "[%s] %r",
test-1  |                     stats,
test-1  |                     sql_util._repr_params(
test-1  |                         parameters, batches=10, ismulti=context.executemany
test-1  |                     ),
test-1  |                 )
test-1  |             else:
test-1  |                 self._log_info(
test-1  |                     "[%s] [SQL parameters hidden due to hide_parameters=True]"
test-1  |                     % (stats,)
test-1  |                 )
test-1  |     
test-1  |         evt_handled = False
test-1  |         try:
test-1  |             if context.executemany:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_executemany:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_executemany(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  |             elif not parameters and context.no_parameters:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute_no_params:
test-1  |                         if fn(cursor, statement, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_execute_no_params(
test-1  |                         cursor, statement, context
test-1  |                     )
test-1  |             else:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  | >                   self.dialect.do_execute(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480a13d390>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               pg8000.dbapi.ProgrammingError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | 
test-1  | The above exception was the direct cause of the following exception:
test-1  | 
test-1  | self = <test_clientes_get.TestClientesGET object at 0x7f4809918e80>
test-1  | json_entrada_nome = 'exemplo5_200'
test-1  | 
test-1  |     @pytest.fixture(scope="class", autouse=True)
test-1  |     def setup(self, json_entrada_nome):
test-1  | >       test_util.pre_setup(json_entrada_nome, True)
test-1  | 
test-1  | tests/api/casos_de_teste/clientes/get/test_clientes_get.py:23: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/tcase_util.py:43: in pre_setup
test-1  |     DumpUtil.dump_from_sqls([self.global_sql], params_tenant)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:18: in dump_from_sqls
test-1  |     DumpUtil.dump_sql_if_exists(file_path, file_params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:135: in dump_sql_if_exists
test-1  |     DumpUtil.dump_from_sql(file_path, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:104: in dump_from_sql
test-1  |     DumpUtil.dump_sql_command(command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:36: in dump_sql_command
test-1  |     response = repository.execute(sql_command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:108: in execute
test-1  |     cursor = self.__execute_retornando_cursor(sql, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:195: in __execute_retornando_cursor
test-1  |     cursor = self.__con.execute(sql2, param3)
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1280: in execute
test-1  |     return self._exec_driver_sql(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1584: in _exec_driver_sql
test-1  |     ret = self._execute_context(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1851: in _execute_context
test-1  |     self._handle_dbapi_exception(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2032: in _handle_dbapi_exception
test-1  |     util.raise_(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/util/compat.py:207: in raise_
test-1  |     raise exception
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: in _execute_context
test-1  |     self.dialect.do_execute(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480a13d390>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               sqlalchemy.exc.ProgrammingError: (pg8000.dbapi.ProgrammingError) query was empty
test-1  | E               [SQL: 
test-1  | E               
test-1  | E               -- INSERT INTO teste.classificacoesfinanceiras
test-1  | E               -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | E               -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | E               (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | _ ERROR at setup of TestClientesGET.test_get[exemplo2_200-/var/www/html/tests/api/casos_de_teste/clientes/get/entradas_json/exemplo2_200.json] _
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480729b520>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  | >               self._context = self._c.execute_simple(operation)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:249: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:617: in execute_simple
test-1  |     self.handle_messages(context)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Connection object at 0x7f4807b0dde0>
test-1  | context = <pg8000.core.Context object at 0x7f480729b670>
test-1  | 
test-1  |     def handle_messages(self, context):
test-1  |         code = self.error = None
test-1  |     
test-1  |         while code != READY_FOR_QUERY:
test-1  |     
test-1  |             try:
test-1  |                 code, data_len = ci_unpack(self._read(5))
test-1  |             except struct.error as e:
test-1  |                 raise InterfaceError("network error on read") from e
test-1  |     
test-1  |             self.message_types[code](self._read(data_len - 4), context)
test-1  |     
test-1  |         if self.error is not None:
test-1  | >           raise self.error
test-1  | E           pg8000.exceptions.DatabaseError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:764: DatabaseError
test-1  | 
test-1  | During handling of the above exception, another exception occurred:
test-1  | 
test-1  | self = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | dialect = <sqlalchemy.dialects.postgresql.pg8000.PGDialect_pg8000 object at 0x7f4808cbfca0>
test-1  | constructor = <bound method DefaultExecutionContext._init_statement of <class 'sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000'>>
test-1  | statement = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | parameters = (), execution_options = immutabledict({})
test-1  | args = ("\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao,...06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)", [])
test-1  | kw = {}, branched = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x7f4807b0ded0>
test-1  | context = <sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000 object at 0x7f480729b7f0>
test-1  | cursor = <pg8000.legacy.Cursor object at 0x7f480729b520>, evt_handled = False
test-1  | 
test-1  |     def _execute_context(
test-1  |         self,
test-1  |         dialect,
test-1  |         constructor,
test-1  |         statement,
test-1  |         parameters,
test-1  |         execution_options,
test-1  |         *args,
test-1  |         **kw
test-1  |     ):
test-1  |         """Create an :class:`.ExecutionContext` and execute, returning
test-1  |         a :class:`_engine.CursorResult`."""
test-1  |     
test-1  |         branched = self
test-1  |         if self.__branch_from:
test-1  |             # if this is a "branched" connection, do everything in terms
test-1  |             # of the "root" connection, *except* for .close(), which is
test-1  |             # the only feature that branching provides
test-1  |             self = self.__branch_from
test-1  |     
test-1  |         try:
test-1  |             conn = self._dbapi_connection
test-1  |             if conn is None:
test-1  |                 conn = self._revalidate_connection()
test-1  |     
test-1  |             context = constructor(
test-1  |                 dialect, self, conn, execution_options, *args, **kw
test-1  |             )
test-1  |         except (exc.PendingRollbackError, exc.ResourceClosedError):
test-1  |             raise
test-1  |         except BaseException as e:
test-1  |             self._handle_dbapi_exception(
test-1  |                 e, util.text_type(statement), parameters, None, None
test-1  |             )
test-1  |     
test-1  |         if (
test-1  |             self._transaction
test-1  |             and not self._transaction.is_active
test-1  |             or (
test-1  |                 self._nested_transaction
test-1  |                 and not self._nested_transaction.is_active
test-1  |             )
test-1  |         ):
test-1  |             self._invalid_transaction()
test-1  |     
test-1  |         elif self._trans_context_manager:
test-1  |             TransactionalContext._trans_ctx_check(self)
test-1  |     
test-1  |         if self._is_future and self._transaction is None:
test-1  |             self._autobegin()
test-1  |     
test-1  |         context.pre_exec()
test-1  |     
test-1  |         if dialect.use_setinputsizes:
test-1  |             context._set_input_sizes()
test-1  |     
test-1  |         cursor, statement, parameters = (
test-1  |             context.cursor,
test-1  |             context.statement,
test-1  |             context.parameters,
test-1  |         )
test-1  |     
test-1  |         if not context.executemany:
test-1  |             parameters = parameters[0]
test-1  |     
test-1  |         if self._has_events or self.engine._has_events:
test-1  |             for fn in self.dispatch.before_cursor_execute:
test-1  |                 statement, parameters = fn(
test-1  |                     self,
test-1  |                     cursor,
test-1  |                     statement,
test-1  |                     parameters,
test-1  |                     context,
test-1  |                     context.executemany,
test-1  |                 )
test-1  |     
test-1  |         if self._echo:
test-1  |     
test-1  |             self._log_info(statement)
test-1  |     
test-1  |             stats = context._get_cache_stats()
test-1  |     
test-1  |             if not self.engine.hide_parameters:
test-1  |                 self._log_info(
test-1  |                     "[%s] %r",
test-1  |                     stats,
test-1  |                     sql_util._repr_params(
test-1  |                         parameters, batches=10, ismulti=context.executemany
test-1  |                     ),
test-1  |                 )
test-1  |             else:
test-1  |                 self._log_info(
test-1  |                     "[%s] [SQL parameters hidden due to hide_parameters=True]"
test-1  |                     % (stats,)
test-1  |                 )
test-1  |     
test-1  |         evt_handled = False
test-1  |         try:
test-1  |             if context.executemany:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_executemany:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_executemany(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  |             elif not parameters and context.no_parameters:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute_no_params:
test-1  |                         if fn(cursor, statement, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_execute_no_params(
test-1  |                         cursor, statement, context
test-1  |                     )
test-1  |             else:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  | >                   self.dialect.do_execute(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480729b520>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               pg8000.dbapi.ProgrammingError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | 
test-1  | The above exception was the direct cause of the following exception:
test-1  | 
test-1  | self = <test_clientes_get.TestClientesGET object at 0x7f4809918e80>
test-1  | json_entrada_nome = 'exemplo2_200'
test-1  | 
test-1  |     @pytest.fixture(scope="class", autouse=True)
test-1  |     def setup(self, json_entrada_nome):
test-1  | >       test_util.pre_setup(json_entrada_nome, True)
test-1  | 
test-1  | tests/api/casos_de_teste/clientes/get/test_clientes_get.py:23: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/tcase_util.py:43: in pre_setup
test-1  |     DumpUtil.dump_from_sqls([self.global_sql], params_tenant)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:18: in dump_from_sqls
test-1  |     DumpUtil.dump_sql_if_exists(file_path, file_params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:135: in dump_sql_if_exists
test-1  |     DumpUtil.dump_from_sql(file_path, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:104: in dump_from_sql
test-1  |     DumpUtil.dump_sql_command(command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:36: in dump_sql_command
test-1  |     response = repository.execute(sql_command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:108: in execute
test-1  |     cursor = self.__execute_retornando_cursor(sql, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:195: in __execute_retornando_cursor
test-1  |     cursor = self.__con.execute(sql2, param3)
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1280: in execute
test-1  |     return self._exec_driver_sql(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1584: in _exec_driver_sql
test-1  |     ret = self._execute_context(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1851: in _execute_context
test-1  |     self._handle_dbapi_exception(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2032: in _handle_dbapi_exception
test-1  |     util.raise_(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/util/compat.py:207: in raise_
test-1  |     raise exception
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: in _execute_context
test-1  |     self.dialect.do_execute(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480729b520>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               sqlalchemy.exc.ProgrammingError: (pg8000.dbapi.ProgrammingError) query was empty
test-1  | E               [SQL: 
test-1  | E               
test-1  | E               -- INSERT INTO teste.classificacoesfinanceiras
test-1  | E               -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | E               -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | E               (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | _ ERROR at setup of TestClientesGET.test_get[exemplo1_200-/var/www/html/tests/api/casos_de_teste/clientes/get/entradas_json/exemplo1_200.json] _
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f4807290190>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  | >               self._context = self._c.execute_simple(operation)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:249: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:617: in execute_simple
test-1  |     self.handle_messages(context)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Connection object at 0x7f4807b0dde0>
test-1  | context = <pg8000.core.Context object at 0x7f48072901f0>
test-1  | 
test-1  |     def handle_messages(self, context):
test-1  |         code = self.error = None
test-1  |     
test-1  |         while code != READY_FOR_QUERY:
test-1  |     
test-1  |             try:
test-1  |                 code, data_len = ci_unpack(self._read(5))
test-1  |             except struct.error as e:
test-1  |                 raise InterfaceError("network error on read") from e
test-1  |     
test-1  |             self.message_types[code](self._read(data_len - 4), context)
test-1  |     
test-1  |         if self.error is not None:
test-1  | >           raise self.error
test-1  | E           pg8000.exceptions.DatabaseError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:764: DatabaseError
test-1  | 
test-1  | During handling of the above exception, another exception occurred:
test-1  | 
test-1  | self = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | dialect = <sqlalchemy.dialects.postgresql.pg8000.PGDialect_pg8000 object at 0x7f4808cbfca0>
test-1  | constructor = <bound method DefaultExecutionContext._init_statement of <class 'sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000'>>
test-1  | statement = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | parameters = (), execution_options = immutabledict({})
test-1  | args = ("\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao,...06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)", [])
test-1  | kw = {}, branched = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x7f4807b0ded0>
test-1  | context = <sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000 object at 0x7f4807290520>
test-1  | cursor = <pg8000.legacy.Cursor object at 0x7f4807290190>, evt_handled = False
test-1  | 
test-1  |     def _execute_context(
test-1  |         self,
test-1  |         dialect,
test-1  |         constructor,
test-1  |         statement,
test-1  |         parameters,
test-1  |         execution_options,
test-1  |         *args,
test-1  |         **kw
test-1  |     ):
test-1  |         """Create an :class:`.ExecutionContext` and execute, returning
test-1  |         a :class:`_engine.CursorResult`."""
test-1  |     
test-1  |         branched = self
test-1  |         if self.__branch_from:
test-1  |             # if this is a "branched" connection, do everything in terms
test-1  |             # of the "root" connection, *except* for .close(), which is
test-1  |             # the only feature that branching provides
test-1  |             self = self.__branch_from
test-1  |     
test-1  |         try:
test-1  |             conn = self._dbapi_connection
test-1  |             if conn is None:
test-1  |                 conn = self._revalidate_connection()
test-1  |     
test-1  |             context = constructor(
test-1  |                 dialect, self, conn, execution_options, *args, **kw
test-1  |             )
test-1  |         except (exc.PendingRollbackError, exc.ResourceClosedError):
test-1  |             raise
test-1  |         except BaseException as e:
test-1  |             self._handle_dbapi_exception(
test-1  |                 e, util.text_type(statement), parameters, None, None
test-1  |             )
test-1  |     
test-1  |         if (
test-1  |             self._transaction
test-1  |             and not self._transaction.is_active
test-1  |             or (
test-1  |                 self._nested_transaction
test-1  |                 and not self._nested_transaction.is_active
test-1  |             )
test-1  |         ):
test-1  |             self._invalid_transaction()
test-1  |     
test-1  |         elif self._trans_context_manager:
test-1  |             TransactionalContext._trans_ctx_check(self)
test-1  |     
test-1  |         if self._is_future and self._transaction is None:
test-1  |             self._autobegin()
test-1  |     
test-1  |         context.pre_exec()
test-1  |     
test-1  |         if dialect.use_setinputsizes:
test-1  |             context._set_input_sizes()
test-1  |     
test-1  |         cursor, statement, parameters = (
test-1  |             context.cursor,
test-1  |             context.statement,
test-1  |             context.parameters,
test-1  |         )
test-1  |     
test-1  |         if not context.executemany:
test-1  |             parameters = parameters[0]
test-1  |     
test-1  |         if self._has_events or self.engine._has_events:
test-1  |             for fn in self.dispatch.before_cursor_execute:
test-1  |                 statement, parameters = fn(
test-1  |                     self,
test-1  |                     cursor,
test-1  |                     statement,
test-1  |                     parameters,
test-1  |                     context,
test-1  |                     context.executemany,
test-1  |                 )
test-1  |     
test-1  |         if self._echo:
test-1  |     
test-1  |             self._log_info(statement)
test-1  |     
test-1  |             stats = context._get_cache_stats()
test-1  |     
test-1  |             if not self.engine.hide_parameters:
test-1  |                 self._log_info(
test-1  |                     "[%s] %r",
test-1  |                     stats,
test-1  |                     sql_util._repr_params(
test-1  |                         parameters, batches=10, ismulti=context.executemany
test-1  |                     ),
test-1  |                 )
test-1  |             else:
test-1  |                 self._log_info(
test-1  |                     "[%s] [SQL parameters hidden due to hide_parameters=True]"
test-1  |                     % (stats,)
test-1  |                 )
test-1  |     
test-1  |         evt_handled = False
test-1  |         try:
test-1  |             if context.executemany:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_executemany:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_executemany(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  |             elif not parameters and context.no_parameters:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute_no_params:
test-1  |                         if fn(cursor, statement, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_execute_no_params(
test-1  |                         cursor, statement, context
test-1  |                     )
test-1  |             else:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  | >                   self.dialect.do_execute(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f4807290190>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               pg8000.dbapi.ProgrammingError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | 
test-1  | The above exception was the direct cause of the following exception:
test-1  | 
test-1  | self = <test_clientes_get.TestClientesGET object at 0x7f4809918e80>
test-1  | json_entrada_nome = 'exemplo1_200'
test-1  | 
test-1  |     @pytest.fixture(scope="class", autouse=True)
test-1  |     def setup(self, json_entrada_nome):
test-1  | >       test_util.pre_setup(json_entrada_nome, True)
test-1  | 
test-1  | tests/api/casos_de_teste/clientes/get/test_clientes_get.py:23: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/tcase_util.py:43: in pre_setup
test-1  |     DumpUtil.dump_from_sqls([self.global_sql], params_tenant)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:18: in dump_from_sqls
test-1  |     DumpUtil.dump_sql_if_exists(file_path, file_params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:135: in dump_sql_if_exists
test-1  |     DumpUtil.dump_from_sql(file_path, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:104: in dump_from_sql
test-1  |     DumpUtil.dump_sql_command(command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:36: in dump_sql_command
test-1  |     response = repository.execute(sql_command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:108: in execute
test-1  |     cursor = self.__execute_retornando_cursor(sql, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:195: in __execute_retornando_cursor
test-1  |     cursor = self.__con.execute(sql2, param3)
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1280: in execute
test-1  |     return self._exec_driver_sql(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1584: in _exec_driver_sql
test-1  |     ret = self._execute_context(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1851: in _execute_context
test-1  |     self._handle_dbapi_exception(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2032: in _handle_dbapi_exception
test-1  |     util.raise_(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/util/compat.py:207: in raise_
test-1  |     raise exception
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: in _execute_context
test-1  |     self.dialect.do_execute(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f4807290190>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               sqlalchemy.exc.ProgrammingError: (pg8000.dbapi.ProgrammingError) query was empty
test-1  | E               [SQL: 
test-1  | E               
test-1  | E               -- INSERT INTO teste.classificacoesfinanceiras
test-1  | E               -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | E               -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | E               (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | _ ERROR at setup of TestClientesGET.test_get[exemplo4_200-/var/www/html/tests/api/casos_de_teste/clientes/get/entradas_json/exemplo4_200.json] _
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f48078fde40>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  | >               self._context = self._c.execute_simple(operation)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:249: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:617: in execute_simple
test-1  |     self.handle_messages(context)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Connection object at 0x7f4807b0dde0>
test-1  | context = <pg8000.core.Context object at 0x7f48078fe590>
test-1  | 
test-1  |     def handle_messages(self, context):
test-1  |         code = self.error = None
test-1  |     
test-1  |         while code != READY_FOR_QUERY:
test-1  |     
test-1  |             try:
test-1  |                 code, data_len = ci_unpack(self._read(5))
test-1  |             except struct.error as e:
test-1  |                 raise InterfaceError("network error on read") from e
test-1  |     
test-1  |             self.message_types[code](self._read(data_len - 4), context)
test-1  |     
test-1  |         if self.error is not None:
test-1  | >           raise self.error
test-1  | E           pg8000.exceptions.DatabaseError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:764: DatabaseError
test-1  | 
test-1  | During handling of the above exception, another exception occurred:
test-1  | 
test-1  | self = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | dialect = <sqlalchemy.dialects.postgresql.pg8000.PGDialect_pg8000 object at 0x7f4808cbfca0>
test-1  | constructor = <bound method DefaultExecutionContext._init_statement of <class 'sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000'>>
test-1  | statement = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | parameters = (), execution_options = immutabledict({})
test-1  | args = ("\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao,...06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)", [])
test-1  | kw = {}, branched = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x7f4807b0ded0>
test-1  | context = <sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000 object at 0x7f48078fe6b0>
test-1  | cursor = <pg8000.legacy.Cursor object at 0x7f48078fde40>, evt_handled = False
test-1  | 
test-1  |     def _execute_context(
test-1  |         self,
test-1  |         dialect,
test-1  |         constructor,
test-1  |         statement,
test-1  |         parameters,
test-1  |         execution_options,
test-1  |         *args,
test-1  |         **kw
test-1  |     ):
test-1  |         """Create an :class:`.ExecutionContext` and execute, returning
test-1  |         a :class:`_engine.CursorResult`."""
test-1  |     
test-1  |         branched = self
test-1  |         if self.__branch_from:
test-1  |             # if this is a "branched" connection, do everything in terms
test-1  |             # of the "root" connection, *except* for .close(), which is
test-1  |             # the only feature that branching provides
test-1  |             self = self.__branch_from
test-1  |     
test-1  |         try:
test-1  |             conn = self._dbapi_connection
test-1  |             if conn is None:
test-1  |                 conn = self._revalidate_connection()
test-1  |     
test-1  |             context = constructor(
test-1  |                 dialect, self, conn, execution_options, *args, **kw
test-1  |             )
test-1  |         except (exc.PendingRollbackError, exc.ResourceClosedError):
test-1  |             raise
test-1  |         except BaseException as e:
test-1  |             self._handle_dbapi_exception(
test-1  |                 e, util.text_type(statement), parameters, None, None
test-1  |             )
test-1  |     
test-1  |         if (
test-1  |             self._transaction
test-1  |             and not self._transaction.is_active
test-1  |             or (
test-1  |                 self._nested_transaction
test-1  |                 and not self._nested_transaction.is_active
test-1  |             )
test-1  |         ):
test-1  |             self._invalid_transaction()
test-1  |     
test-1  |         elif self._trans_context_manager:
test-1  |             TransactionalContext._trans_ctx_check(self)
test-1  |     
test-1  |         if self._is_future and self._transaction is None:
test-1  |             self._autobegin()
test-1  |     
test-1  |         context.pre_exec()
test-1  |     
test-1  |         if dialect.use_setinputsizes:
test-1  |             context._set_input_sizes()
test-1  |     
test-1  |         cursor, statement, parameters = (
test-1  |             context.cursor,
test-1  |             context.statement,
test-1  |             context.parameters,
test-1  |         )
test-1  |     
test-1  |         if not context.executemany:
test-1  |             parameters = parameters[0]
test-1  |     
test-1  |         if self._has_events or self.engine._has_events:
test-1  |             for fn in self.dispatch.before_cursor_execute:
test-1  |                 statement, parameters = fn(
test-1  |                     self,
test-1  |                     cursor,
test-1  |                     statement,
test-1  |                     parameters,
test-1  |                     context,
test-1  |                     context.executemany,
test-1  |                 )
test-1  |     
test-1  |         if self._echo:
test-1  |     
test-1  |             self._log_info(statement)
test-1  |     
test-1  |             stats = context._get_cache_stats()
test-1  |     
test-1  |             if not self.engine.hide_parameters:
test-1  |                 self._log_info(
test-1  |                     "[%s] %r",
test-1  |                     stats,
test-1  |                     sql_util._repr_params(
test-1  |                         parameters, batches=10, ismulti=context.executemany
test-1  |                     ),
test-1  |                 )
test-1  |             else:
test-1  |                 self._log_info(
test-1  |                     "[%s] [SQL parameters hidden due to hide_parameters=True]"
test-1  |                     % (stats,)
test-1  |                 )
test-1  |     
test-1  |         evt_handled = False
test-1  |         try:
test-1  |             if context.executemany:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_executemany:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_executemany(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  |             elif not parameters and context.no_parameters:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute_no_params:
test-1  |                         if fn(cursor, statement, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_execute_no_params(
test-1  |                         cursor, statement, context
test-1  |                     )
test-1  |             else:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  | >                   self.dialect.do_execute(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f48078fde40>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               pg8000.dbapi.ProgrammingError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | 
test-1  | The above exception was the direct cause of the following exception:
test-1  | 
test-1  | self = <test_clientes_get.TestClientesGET object at 0x7f4809918e80>
test-1  | json_entrada_nome = 'exemplo4_200'
test-1  | 
test-1  |     @pytest.fixture(scope="class", autouse=True)
test-1  |     def setup(self, json_entrada_nome):
test-1  | >       test_util.pre_setup(json_entrada_nome, True)
test-1  | 
test-1  | tests/api/casos_de_teste/clientes/get/test_clientes_get.py:23: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/tcase_util.py:43: in pre_setup
test-1  |     DumpUtil.dump_from_sqls([self.global_sql], params_tenant)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:18: in dump_from_sqls
test-1  |     DumpUtil.dump_sql_if_exists(file_path, file_params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:135: in dump_sql_if_exists
test-1  |     DumpUtil.dump_from_sql(file_path, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:104: in dump_from_sql
test-1  |     DumpUtil.dump_sql_command(command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:36: in dump_sql_command
test-1  |     response = repository.execute(sql_command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:108: in execute
test-1  |     cursor = self.__execute_retornando_cursor(sql, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:195: in __execute_retornando_cursor
test-1  |     cursor = self.__con.execute(sql2, param3)
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1280: in execute
test-1  |     return self._exec_driver_sql(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1584: in _exec_driver_sql
test-1  |     ret = self._execute_context(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1851: in _execute_context
test-1  |     self._handle_dbapi_exception(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2032: in _handle_dbapi_exception
test-1  |     util.raise_(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/util/compat.py:207: in raise_
test-1  |     raise exception
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: in _execute_context
test-1  |     self.dialect.do_execute(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f48078fde40>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               sqlalchemy.exc.ProgrammingError: (pg8000.dbapi.ProgrammingError) query was empty
test-1  | E               [SQL: 
test-1  | E               
test-1  | E               -- INSERT INTO teste.classificacoesfinanceiras
test-1  | E               -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | E               -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | E               (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | _ ERROR at setup of TestClientesPOST.test_post[exemplo1_201-/var/www/html/tests/api/casos_de_teste/clientes/post/entradas_json/exemplo1_201.json] _
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480729e380>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  | >               self._context = self._c.execute_simple(operation)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:249: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:617: in execute_simple
test-1  |     self.handle_messages(context)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Connection object at 0x7f4807b0dde0>
test-1  | context = <pg8000.core.Context object at 0x7f480729e3e0>
test-1  | 
test-1  |     def handle_messages(self, context):
test-1  |         code = self.error = None
test-1  |     
test-1  |         while code != READY_FOR_QUERY:
test-1  |     
test-1  |             try:
test-1  |                 code, data_len = ci_unpack(self._read(5))
test-1  |             except struct.error as e:
test-1  |                 raise InterfaceError("network error on read") from e
test-1  |     
test-1  |             self.message_types[code](self._read(data_len - 4), context)
test-1  |     
test-1  |         if self.error is not None:
test-1  | >           raise self.error
test-1  | E           pg8000.exceptions.DatabaseError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:764: DatabaseError
test-1  | 
test-1  | During handling of the above exception, another exception occurred:
test-1  | 
test-1  | self = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | dialect = <sqlalchemy.dialects.postgresql.pg8000.PGDialect_pg8000 object at 0x7f4808cbfca0>
test-1  | constructor = <bound method DefaultExecutionContext._init_statement of <class 'sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000'>>
test-1  | statement = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | parameters = (), execution_options = immutabledict({})
test-1  | args = ("\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao,...06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)", [])
test-1  | kw = {}, branched = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x7f4807b0ded0>
test-1  | context = <sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000 object at 0x7f480729e350>
test-1  | cursor = <pg8000.legacy.Cursor object at 0x7f480729e380>, evt_handled = False
test-1  | 
test-1  |     def _execute_context(
test-1  |         self,
test-1  |         dialect,
test-1  |         constructor,
test-1  |         statement,
test-1  |         parameters,
test-1  |         execution_options,
test-1  |         *args,
test-1  |         **kw
test-1  |     ):
test-1  |         """Create an :class:`.ExecutionContext` and execute, returning
test-1  |         a :class:`_engine.CursorResult`."""
test-1  |     
test-1  |         branched = self
test-1  |         if self.__branch_from:
test-1  |             # if this is a "branched" connection, do everything in terms
test-1  |             # of the "root" connection, *except* for .close(), which is
test-1  |             # the only feature that branching provides
test-1  |             self = self.__branch_from
test-1  |     
test-1  |         try:
test-1  |             conn = self._dbapi_connection
test-1  |             if conn is None:
test-1  |                 conn = self._revalidate_connection()
test-1  |     
test-1  |             context = constructor(
test-1  |                 dialect, self, conn, execution_options, *args, **kw
test-1  |             )
test-1  |         except (exc.PendingRollbackError, exc.ResourceClosedError):
test-1  |             raise
test-1  |         except BaseException as e:
test-1  |             self._handle_dbapi_exception(
test-1  |                 e, util.text_type(statement), parameters, None, None
test-1  |             )
test-1  |     
test-1  |         if (
test-1  |             self._transaction
test-1  |             and not self._transaction.is_active
test-1  |             or (
test-1  |                 self._nested_transaction
test-1  |                 and not self._nested_transaction.is_active
test-1  |             )
test-1  |         ):
test-1  |             self._invalid_transaction()
test-1  |     
test-1  |         elif self._trans_context_manager:
test-1  |             TransactionalContext._trans_ctx_check(self)
test-1  |     
test-1  |         if self._is_future and self._transaction is None:
test-1  |             self._autobegin()
test-1  |     
test-1  |         context.pre_exec()
test-1  |     
test-1  |         if dialect.use_setinputsizes:
test-1  |             context._set_input_sizes()
test-1  |     
test-1  |         cursor, statement, parameters = (
test-1  |             context.cursor,
test-1  |             context.statement,
test-1  |             context.parameters,
test-1  |         )
test-1  |     
test-1  |         if not context.executemany:
test-1  |             parameters = parameters[0]
test-1  |     
test-1  |         if self._has_events or self.engine._has_events:
test-1  |             for fn in self.dispatch.before_cursor_execute:
test-1  |                 statement, parameters = fn(
test-1  |                     self,
test-1  |                     cursor,
test-1  |                     statement,
test-1  |                     parameters,
test-1  |                     context,
test-1  |                     context.executemany,
test-1  |                 )
test-1  |     
test-1  |         if self._echo:
test-1  |     
test-1  |             self._log_info(statement)
test-1  |     
test-1  |             stats = context._get_cache_stats()
test-1  |     
test-1  |             if not self.engine.hide_parameters:
test-1  |                 self._log_info(
test-1  |                     "[%s] %r",
test-1  |                     stats,
test-1  |                     sql_util._repr_params(
test-1  |                         parameters, batches=10, ismulti=context.executemany
test-1  |                     ),
test-1  |                 )
test-1  |             else:
test-1  |                 self._log_info(
test-1  |                     "[%s] [SQL parameters hidden due to hide_parameters=True]"
test-1  |                     % (stats,)
test-1  |                 )
test-1  |     
test-1  |         evt_handled = False
test-1  |         try:
test-1  |             if context.executemany:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_executemany:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_executemany(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  |             elif not parameters and context.no_parameters:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute_no_params:
test-1  |                         if fn(cursor, statement, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_execute_no_params(
test-1  |                         cursor, statement, context
test-1  |                     )
test-1  |             else:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  | >                   self.dialect.do_execute(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480729e380>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               pg8000.dbapi.ProgrammingError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | 
test-1  | The above exception was the direct cause of the following exception:
test-1  | 
test-1  | self = <test_clientes_post.TestClientesPOST object at 0x7f4809919b10>
test-1  | json_entrada_nome = 'exemplo1_201'
test-1  | 
test-1  |     @pytest.fixture(scope="class", autouse=True)
test-1  |     def setup(self, json_entrada_nome):
test-1  | >       test_util.pre_setup(json_entrada_nome, False)
test-1  | 
test-1  | tests/api/casos_de_teste/clientes/post/test_clientes_post.py:21: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/tcase_util.py:43: in pre_setup
test-1  |     DumpUtil.dump_from_sqls([self.global_sql], params_tenant)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:18: in dump_from_sqls
test-1  |     DumpUtil.dump_sql_if_exists(file_path, file_params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:135: in dump_sql_if_exists
test-1  |     DumpUtil.dump_from_sql(file_path, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:104: in dump_from_sql
test-1  |     DumpUtil.dump_sql_command(command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:36: in dump_sql_command
test-1  |     response = repository.execute(sql_command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:108: in execute
test-1  |     cursor = self.__execute_retornando_cursor(sql, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:195: in __execute_retornando_cursor
test-1  |     cursor = self.__con.execute(sql2, param3)
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1280: in execute
test-1  |     return self._exec_driver_sql(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1584: in _exec_driver_sql
test-1  |     ret = self._execute_context(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1851: in _execute_context
test-1  |     self._handle_dbapi_exception(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2032: in _handle_dbapi_exception
test-1  |     util.raise_(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/util/compat.py:207: in raise_
test-1  |     raise exception
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: in _execute_context
test-1  |     self.dialect.do_execute(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480729e380>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               sqlalchemy.exc.ProgrammingError: (pg8000.dbapi.ProgrammingError) query was empty
test-1  | E               [SQL: 
test-1  | E               
test-1  | E               -- INSERT INTO teste.classificacoesfinanceiras
test-1  | E               -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | E               -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | E               (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | _ ERROR at setup of TestClientesPUT.test_get[exemplo1_204-/var/www/html/tests/api/casos_de_teste/clientes/put/entradas_json/exemplo1_204.json] _
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480780b850>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  | >               self._context = self._c.execute_simple(operation)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:249: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:617: in execute_simple
test-1  |     self.handle_messages(context)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Connection object at 0x7f4807b0dde0>
test-1  | context = <pg8000.core.Context object at 0x7f480780b880>
test-1  | 
test-1  |     def handle_messages(self, context):
test-1  |         code = self.error = None
test-1  |     
test-1  |         while code != READY_FOR_QUERY:
test-1  |     
test-1  |             try:
test-1  |                 code, data_len = ci_unpack(self._read(5))
test-1  |             except struct.error as e:
test-1  |                 raise InterfaceError("network error on read") from e
test-1  |     
test-1  |             self.message_types[code](self._read(data_len - 4), context)
test-1  |     
test-1  |         if self.error is not None:
test-1  | >           raise self.error
test-1  | E           pg8000.exceptions.DatabaseError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/core.py:764: DatabaseError
test-1  | 
test-1  | During handling of the above exception, another exception occurred:
test-1  | 
test-1  | self = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | dialect = <sqlalchemy.dialects.postgresql.pg8000.PGDialect_pg8000 object at 0x7f4808cbfca0>
test-1  | constructor = <bound method DefaultExecutionContext._init_statement of <class 'sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000'>>
test-1  | statement = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | parameters = (), execution_options = immutabledict({})
test-1  | args = ("\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao,...06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)", [])
test-1  | kw = {}, branched = <sqlalchemy.engine.base.Connection object at 0x7f480991b6a0>
test-1  | conn = <sqlalchemy.pool.base._ConnectionFairy object at 0x7f4807b0ded0>
test-1  | context = <sqlalchemy.dialects.postgresql.pg8000.PGExecutionContext_pg8000 object at 0x7f480780b910>
test-1  | cursor = <pg8000.legacy.Cursor object at 0x7f480780b850>, evt_handled = False
test-1  | 
test-1  |     def _execute_context(
test-1  |         self,
test-1  |         dialect,
test-1  |         constructor,
test-1  |         statement,
test-1  |         parameters,
test-1  |         execution_options,
test-1  |         *args,
test-1  |         **kw
test-1  |     ):
test-1  |         """Create an :class:`.ExecutionContext` and execute, returning
test-1  |         a :class:`_engine.CursorResult`."""
test-1  |     
test-1  |         branched = self
test-1  |         if self.__branch_from:
test-1  |             # if this is a "branched" connection, do everything in terms
test-1  |             # of the "root" connection, *except* for .close(), which is
test-1  |             # the only feature that branching provides
test-1  |             self = self.__branch_from
test-1  |     
test-1  |         try:
test-1  |             conn = self._dbapi_connection
test-1  |             if conn is None:
test-1  |                 conn = self._revalidate_connection()
test-1  |     
test-1  |             context = constructor(
test-1  |                 dialect, self, conn, execution_options, *args, **kw
test-1  |             )
test-1  |         except (exc.PendingRollbackError, exc.ResourceClosedError):
test-1  |             raise
test-1  |         except BaseException as e:
test-1  |             self._handle_dbapi_exception(
test-1  |                 e, util.text_type(statement), parameters, None, None
test-1  |             )
test-1  |     
test-1  |         if (
test-1  |             self._transaction
test-1  |             and not self._transaction.is_active
test-1  |             or (
test-1  |                 self._nested_transaction
test-1  |                 and not self._nested_transaction.is_active
test-1  |             )
test-1  |         ):
test-1  |             self._invalid_transaction()
test-1  |     
test-1  |         elif self._trans_context_manager:
test-1  |             TransactionalContext._trans_ctx_check(self)
test-1  |     
test-1  |         if self._is_future and self._transaction is None:
test-1  |             self._autobegin()
test-1  |     
test-1  |         context.pre_exec()
test-1  |     
test-1  |         if dialect.use_setinputsizes:
test-1  |             context._set_input_sizes()
test-1  |     
test-1  |         cursor, statement, parameters = (
test-1  |             context.cursor,
test-1  |             context.statement,
test-1  |             context.parameters,
test-1  |         )
test-1  |     
test-1  |         if not context.executemany:
test-1  |             parameters = parameters[0]
test-1  |     
test-1  |         if self._has_events or self.engine._has_events:
test-1  |             for fn in self.dispatch.before_cursor_execute:
test-1  |                 statement, parameters = fn(
test-1  |                     self,
test-1  |                     cursor,
test-1  |                     statement,
test-1  |                     parameters,
test-1  |                     context,
test-1  |                     context.executemany,
test-1  |                 )
test-1  |     
test-1  |         if self._echo:
test-1  |     
test-1  |             self._log_info(statement)
test-1  |     
test-1  |             stats = context._get_cache_stats()
test-1  |     
test-1  |             if not self.engine.hide_parameters:
test-1  |                 self._log_info(
test-1  |                     "[%s] %r",
test-1  |                     stats,
test-1  |                     sql_util._repr_params(
test-1  |                         parameters, batches=10, ismulti=context.executemany
test-1  |                     ),
test-1  |                 )
test-1  |             else:
test-1  |                 self._log_info(
test-1  |                     "[%s] [SQL parameters hidden due to hide_parameters=True]"
test-1  |                     % (stats,)
test-1  |                 )
test-1  |     
test-1  |         evt_handled = False
test-1  |         try:
test-1  |             if context.executemany:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_executemany:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_executemany(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  |             elif not parameters and context.no_parameters:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute_no_params:
test-1  |                         if fn(cursor, statement, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  |                     self.dialect.do_execute_no_params(
test-1  |                         cursor, statement, context
test-1  |                     )
test-1  |             else:
test-1  |                 if self.dialect._has_events:
test-1  |                     for fn in self.dialect.dispatch.do_execute:
test-1  |                         if fn(cursor, statement, parameters, context):
test-1  |                             evt_handled = True
test-1  |                             break
test-1  |                 if not evt_handled:
test-1  | >                   self.dialect.do_execute(
test-1  |                         cursor, statement, parameters, context
test-1  |                     )
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480780b850>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               pg8000.dbapi.ProgrammingError: query was empty
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | 
test-1  | The above exception was the direct cause of the following exception:
test-1  | 
test-1  | self = <test_clientes_put.TestClientesPUT object at 0x7f480991aaa0>
test-1  | json_entrada_nome = 'exemplo1_204'
test-1  | 
test-1  |     @pytest.fixture(scope="class", autouse=True)
test-1  |     def setup(self, json_entrada_nome):
test-1  | >       test_util.pre_setup(json_entrada_nome, True)
test-1  | 
test-1  | tests/api/casos_de_teste/clientes/put/test_clientes_put.py:24: 
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/tcase_util.py:43: in pre_setup
test-1  |     DumpUtil.dump_from_sqls([self.global_sql], params_tenant)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:18: in dump_from_sqls
test-1  |     DumpUtil.dump_sql_if_exists(file_path, file_params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:135: in dump_sql_if_exists
test-1  |     DumpUtil.dump_from_sql(file_path, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:104: in dump_from_sql
test-1  |     DumpUtil.dump_sql_command(command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/util/dump_util.py:36: in dump_sql_command
test-1  |     response = repository.execute(sql_command, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:108: in execute
test-1  |     cursor = self.__execute_retornando_cursor(sql, params)
test-1  | /usr/lib/python3.10/site-packages/nsj_rest_test_util/dao/repository/abstract_repository.py:195: in __execute_retornando_cursor
test-1  |     cursor = self.__con.execute(sql2, param3)
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1280: in execute
test-1  |     return self._exec_driver_sql(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1584: in _exec_driver_sql
test-1  |     ret = self._execute_context(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1851: in _execute_context
test-1  |     self._handle_dbapi_exception(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:2032: in _handle_dbapi_exception
test-1  |     util.raise_(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/util/compat.py:207: in raise_
test-1  |     raise exception
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/base.py:1808: in _execute_context
test-1  |     self.dialect.do_execute(
test-1  | /usr/lib/python3.10/site-packages/sqlalchemy/engine/default.py:732: in do_execute
test-1  |     cursor.execute(statement, parameters)
test-1  | _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ 
test-1  | 
test-1  | self = <pg8000.legacy.Cursor object at 0x7f480780b850>
test-1  | operation = "\n\n-- INSERT INTO teste.classificacoesfinanceiras\n-- (codigo, descricao, codigocontabil, resumo, situacao, versao, ...5-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)"
test-1  | args = (), stream = None
test-1  | 
test-1  |     def execute(self, operation, args=(), stream=None):
test-1  |         """Executes a database operation.  Parameters may be provided as a
test-1  |         sequence, or as a mapping, depending upon the value of
test-1  |         :data:`pg8000.paramstyle`.
test-1  |     
test-1  |         This method is part of the `DBAPI 2.0 specification
test-1  |         <http://www.python.org/dev/peps/pep-0249/>`_.
test-1  |     
test-1  |         :param operation:
test-1  |             The SQL statement to execute.
test-1  |     
test-1  |         :param args:
test-1  |             If :data:`paramstyle` is ``qmark``, ``numeric``, or ``format``,
test-1  |             this argument should be an array of parameters to bind into the
test-1  |             statement.  If :data:`paramstyle` is ``named``, the argument should
test-1  |             be a dict mapping of parameters.  If the :data:`paramstyle` is
test-1  |             ``pyformat``, the argument value may be either an array or a
test-1  |             mapping.
test-1  |     
test-1  |         :param stream: This is a pg8000 extension for use with the PostgreSQL
test-1  |             `COPY
test-1  |             <http://www.postgresql.org/docs/current/static/sql-copy.html>`_
test-1  |             command. For a COPY FROM the parameter must be a readable file-like
test-1  |             object, and for COPY TO it must be writable.
test-1  |     
test-1  |             .. versionadded:: 1.9.11
test-1  |         """
test-1  |         try:
test-1  |             if not self._c.in_transaction and not self._c.autocommit:
test-1  |                 self._c.execute_simple("begin transaction")
test-1  |     
test-1  |             if len(args) == 0 and stream is None:
test-1  |                 self._context = self._c.execute_simple(operation)
test-1  |             else:
test-1  |                 statement, vals = convert_paramstyle(self.paramstyle, operation, args)
test-1  |                 self._context = self._c.execute_unnamed(
test-1  |                     statement, vals=vals, oids=self._input_oids, stream=stream
test-1  |                 )
test-1  |     
test-1  |             rows = [] if self._context.rows is None else self._context.rows
test-1  |             self._row_iter = iter(rows)
test-1  |     
test-1  |             self._input_oids = ()
test-1  |         except AttributeError as e:
test-1  |             if self._c is None:
test-1  |                 raise InterfaceError("Cursor closed")
test-1  |             elif self._c._sock is None:
test-1  |                 raise InterfaceError("connection is closed")
test-1  |             else:
test-1  |                 raise e
test-1  |         except DatabaseError as e:
test-1  |             msg = e.args[0]
test-1  |             if isinstance(msg, dict):
test-1  |                 response_code = msg["C"]
test-1  |     
test-1  |                 if response_code == "28000":
test-1  |                     cls = InterfaceError
test-1  |                 elif response_code == "23505":
test-1  |                     cls = IntegrityError
test-1  |                 else:
test-1  |                     cls = ProgrammingError
test-1  |     
test-1  |                 raise cls(msg)
test-1  |             else:
test-1  | >               raise ProgrammingError(msg)
test-1  | E               sqlalchemy.exc.ProgrammingError: (pg8000.dbapi.ProgrammingError) query was empty
test-1  | E               [SQL: 
test-1  | E               
test-1  | E               -- INSERT INTO teste.classificacoesfinanceiras
test-1  | E               -- (codigo, descricao, codigocontabil, resumo, situacao, versao, natureza, classificacaofinanceira, paiid, grupoempresarial, lastupdate, resumoexplicativo, importacao_hash, iniciogrupo, apenasagrupador, id_erp, padrao, transferencia, repasse_deducao, tenant, rendimentos, categoriafinanceira, grupobalancete, atributo1, atributo2, atributo3)
test-1  | E               -- VALUES('teste-04', 'Classificação para teste do insert por funcao', NULL, NULL, 0, 1, 2, uuid_generate_v4(), NULL, '3964bfdc-e09e-4386-9655-5296062e632d'::uuid, '2025-11-06 14:28:16.429', NULL, NULL, false, false, NULL, false, false, false, NULL, false, NULL, NULL, NULL, NULL, NULL)]
test-1  | E               (Background on this error at: https://sqlalche.me/e/14/f405)
test-1  | 
test-1  | /usr/lib/python3.10/site-packages/pg8000/legacy.py:281: ProgrammingError
test-1  | =========================== short test summary info ============================
test-1  | ERROR tests/api/casos_de_teste/clientes/delete/test_clientes_delete.py::TestClientesDELETE::test_get[exemplo1_204-/var/www/html/tests/api/casos_de_teste/clientes/delete/entradas_json/exemplo1_204.json]
test-1  | ERROR tests/api/casos_de_teste/clientes/delete/test_clientes_delete.py::TestClientesDELETE::test_get[exemplo2_204-/var/www/html/tests/api/casos_de_teste/clientes/delete/entradas_json/exemplo2_204.json]
test-1  | ERROR tests/api/casos_de_teste/clientes/get/test_clientes_get.py::TestClientesGET::test_get[exemplo3_200-/var/www/html/tests/api/casos_de_teste/clientes/get/entradas_json/exemplo3_200.json]
test-1  | ERROR tests/api/casos_de_teste/clientes/get/test_clientes_get.py::TestClientesGET::test_get[exemplo5_200-/var/www/html/tests/api/casos_de_teste/clientes/get/entradas_json/exemplo5_200.json]
test-1  | ERROR tests/api/casos_de_teste/clientes/get/test_clientes_get.py::TestClientesGET::test_get[exemplo2_200-/var/www/html/tests/api/casos_de_teste/clientes/get/entradas_json/exemplo2_200.json]
test-1  | ERROR tests/api/casos_de_teste/clientes/get/test_clientes_get.py::TestClientesGET::test_get[exemplo1_200-/var/www/html/tests/api/casos_de_teste/clientes/get/entradas_json/exemplo1_200.json]
test-1  | ERROR tests/api/casos_de_teste/clientes/get/test_clientes_get.py::TestClientesGET::test_get[exemplo4_200-/var/www/html/tests/api/casos_de_teste/clientes/get/entradas_json/exemplo4_200.json]
test-1  | ERROR tests/api/casos_de_teste/clientes/post/test_clientes_post.py::TestClientesPOST::test_post[exemplo1_201-/var/www/html/tests/api/casos_de_teste/clientes/post/entradas_json/exemplo1_201.json]
test-1  | ERROR tests/api/casos_de_teste/clientes/put/test_clientes_put.py::TestClientesPUT::test_get[exemplo1_204-/var/www/html/tests/api/casos_de_teste/clientes/put/entradas_json/exemplo1_204.json]
test-1  | ============================== 9 errors in 2.02s ===============================
[Ktest-1 exited with code 1
